#include "aitrace.h"
#include <fstream>
#include <sstream>
#include <iomanip>
#include <ctime>
#include <chrono>
#include <filesystem>
using namespace std;
// 构造
AITrace::AITrace()
{
    root_dir = "ai_trace";
}

// 析构
AITrace::~AITrace()
{
}

// 设置根目录
void AITrace::setRootDir(const std::string& dir)
{
    root_dir = dir;
}

// 开始一次 AI 调用记录
void AITrace::begin(
    const std::string& role_name,
    int ai_mode,
    const std::string& user_text,
    const std::string& prompt_text
)
{

    ctx = TraceContext();

    ctx.active = true;
    ctx.role_name = role_name;
    ctx.ai_mode = ai_mode;
    ctx.user_text = user_text;
    ctx.prompt_text = prompt_text;
    ctx.begin_time = nowMs();
}

// 记录调试信息
void AITrace::debug(const std::string& text)
{
    if (!ctx.active)
        return;

    DebugItem item;
    item.timestamp = nowMs();
    item.text = text;
    ctx.debug_logs.push_back(item);
}

// 结束一次 AI 调用并写文件
void AITrace::end(
    bool ok,
    const std::string& output_text
)
{
    if (!ctx.active)
        return;

    ctx.ok = ok;
    ctx.output_text = output_text;
    ctx.end_time = nowMs();

    writeToFile();
    reset();
}

// 重置当前 trace
void AITrace::reset()
{
    ctx = TraceContext();
}

// 当前时间戳（毫秒）
uint64_t AITrace::nowMs()
{
    using namespace std::chrono;
    return duration_cast<milliseconds>(
        system_clock::now().time_since_epoch()
    ).count();
}

// 子目录
std::string AITrace::modeDir(int ai_mode)
{
    switch (ai_mode)
    {
    case 1: return "chat_cloud";
    case 2: return "chat_local";
    case 3: return "reason_cloud";
    case 4: return "reason_local";
    default: return "unknown";
    }
}

// 文件名
std::string AITrace::makeFileName(uint64_t timestamp)
{
    std::time_t t = static_cast<std::time_t>(timestamp / 1000);
    std::tm tm{};
#if defined(_WIN32)
    localtime_s(&tm, &t);
#else
    localtime_r(&t, &tm);
#endif

    std::ostringstream oss;
    oss << std::put_time(&tm, "%Y%m%d_%H%M%S");
    oss << "_" << std::setw(3) << std::setfill('0') << (timestamp % 1000);
    oss << ".txt";

    return oss.str();
}

// 写入文件（只在 end 调用）
void AITrace::writeToFile()
{

    std::string dir = root_dir + "/" + modeDir(ctx.ai_mode);
    std::filesystem::create_directories(dir);

    std::string file_path =
        dir + "/" + makeFileName(ctx.begin_time);

    std::ofstream ofs(file_path, std::ios::out | std::ios::binary);
    if (!ofs.is_open())
        return;

    // -------- 文件头（个人标识，不影响结构）--------
    ofs.write("\xEF\xBB\xBF", 3);
    ofs << "// AI TRACE LOG\n";
    ofs << "// owner: fuduji\n";
    ofs << "// generated by fuduji plc-ai system\n\n";

    ofs << "[TRACE]\n";
    ofs << "role = " << ctx.role_name << "\n";
    ofs << "ai_mode = " << ctx.ai_mode << "\n";
    ofs << "ok = " << (ctx.ok ? "true" : "false") << "\n";
    ofs << "timestamp_begin = " << ctx.begin_time << "\n";
    ofs << "timestamp_end = " << ctx.end_time << "\n";
    ofs << "author = fuduji\n\n";

    ofs << "[USER_INPUT]\n";
    ofs << ctx.user_text << "\n\n";

    ofs << "[PROMPT]\n";
    ofs << ctx.prompt_text << "\n\n";

    ofs << "[DEBUG]\n";
    if (ctx.debug_logs.empty())
    {
        ofs << "(none)\n";
    }
    else
    {
        for (const auto& d : ctx.debug_logs)
        {
            ofs << "- [" << d.timestamp << "] " << d.text << "\n";
        }
    }
    ofs << "\n";

    ofs << "[AI_OUTPUT]\n";
    ofs << ctx.output_text << "\n";

    ofs.close();
}
